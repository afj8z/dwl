--- dwl.c
+++ dwl.c
@@ -88,7 +93,7 @@
 /* enums */
 enum { CurNormal, CurPressed, CurMove, CurResize }; /* cursor */
 enum { XDGShell, LayerShell, X11 }; /* client types */
-enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrTop, LyrFS, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
+enum { LyrBg, LyrBlur, LyrBottom, LyrTile, LyrFloat, LyrTop, LyrFS, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
 #ifdef XWAYLAND
 enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
 	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
@@ -146,6 +151,12 @@ typedef struct {
 	uint32_t tags;
 	int isfloating, isurgent, isfullscreen;
 	uint32_t resize; /* configure serial of a pending resize */
+
+	float opacity;
+	int corner_radius;
+	struct wlr_scene_shadow *shadow;
+	int has_shadow_enabled;
+	struct wlr_scene_rect *round_border;
 } Client;
 
 typedef struct {
@@ -213,6 +224,7 @@ struct Monitor {
 	int nmaster;
 	char ltsymbol[16];
 	int asleep;
+	struct wlr_scene_optimized_blur *blur_layer;
 };
 
 typedef struct {
@@ -518,6 +544,10 @@ arrange(Monitor *m)
 	wlr_scene_node_set_enabled(&m->fullscreen_bg->node,
 			(c = focustop(m)) && c->isfullscreen);
 
+	if (blur) {
+		wlr_scene_node_set_enabled(&m->blur_layer->node, 1);
+	}
+
 	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, LENGTH(m->ltsymbol));
 
 	/* We move all clients (except fullscreen and unmanaged) to LyrTile while
@@ -741,6 +771,11 @@ cleanupmon(struct wl_listener *listener, void *data)
 
 	closemon(m);
 	wlr_scene_node_destroy(&m->fullscreen_bg->node);
+
+	if (blur) {
+		wlr_scene_node_destroy(&m->blur_layer->node);
+	}
+
 	free(m);
 }
 
@@ -804,6 +839,18 @@ commitlayersurfacenotify(struct wl_listener *listener, void *data)
 	}
 
 	arrangelayers(l->mon);
+
+	if (blur) {
+		// Rerender the optimized blur on change
+		struct wlr_layer_surface_v1 *wlr_layer_surface = l->layer_surface;
+		if (wlr_layer_surface->current.layer ==
+				ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND ||
+			wlr_layer_surface->current.layer == ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM) {
+			if (l->mon) {
+				wlr_scene_optimized_blur_mark_dirty(l->mon->blur_layer);
+			}
+		}
+	}
 }
 
 void
@@ -1055,6 +1102,12 @@ createmon(struct wl_listener *listener, void *data)
 	m->fullscreen_bg = wlr_scene_rect_create(layers[LyrFS], 0, 0, fullscreen_bg);
 	wlr_scene_node_set_enabled(&m->fullscreen_bg->node, 0);
 
+	if (blur) {
+		m->blur_layer = wlr_scene_optimized_blur_create(&scene->tree, 0, 0);
+		wlr_scene_node_reparent(&m->blur_layer->node, layers[LyrBlur]);
+		wlr_scene_node_set_enabled(&m->blur_layer->node, 0);
+	}
+
 	/* Adds this to the output layout in the order it was configured.
 	 *
 	 * The output layout utility automatically adds a wl_output global to the
@@ -1080,6 +1133,9 @@ createnotify(struct wl_listener *listener, void *data)
 	c->surface.xdg = toplevel->base;
 	c->bw = borderpx;
 
+	c->opacity = opacity;
+	c->corner_radius = corner_radius;
+
 	LISTEN(&toplevel->base->surface->events.commit, &c->commit, commitnotify);
 	LISTEN(&toplevel->base->surface->events.map, &c->map, mapnotify);
 	LISTEN(&toplevel->base->surface->events.unmap, &c->unmap, unmapnotify);
@@ -1388,8 +1444,11 @@ focusclient(Client *c, int lift)
 
 		/* Don't change border color if there is an exclusive focus or we are
 		 * handling a drag operation */
-		if (!exclusive_focus && !seat->drag)
+		if (!exclusive_focus && !seat->drag) {
 			client_set_border_color(c, focuscolor);
+
+			update_client_focus_decorations(c, 1, 0);
+		}
 	}
 
 	/* Deactivate old client if focus is changing */
@@ -1408,6 +1467,8 @@ focusclient(Client *c, int lift)
 		} else if (old_c && !client_is_unmanaged(old_c) && (!c || !client_wants_focus(c))) {
 			client_set_border_color(old_c, bordercolor);
 
+			update_client_focus_decorations(old_c, 0, 0);
+
 			client_activate_surface(old, 0);
 		}
 	}
@@ -1737,6 +1798,38 @@ mapnotify(struct wl_listener *listener, void *data)
 		c->border[i]->node.data = c;
 	}
 
+	wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers, c);
+
+#ifdef XWAYLAND
+	if (!client_is_x11(c)) {
+#endif
+	if (corner_radius > 0) {
+		c->round_border = wlr_scene_rect_create(c->scene, 0, 0, c->isurgent ? urgentcolor : bordercolor);
+		c->round_border->node.data = c;
+		/* Lower the border below the XDG scene tree */
+		wlr_scene_node_lower_to_bottom(&c->round_border->node);
+
+		/* hide original border */
+		for (i = 0; i < 4; i++) {
+			wlr_scene_rect_set_color(c->border[i], transparent);
+		}
+	}
+#ifdef XWAYLAND
+	}
+#endif
+
+#ifdef XWAYLAND
+	if (!client_is_x11(c)) {
+#endif
+	if (shadow) {
+		c->shadow = wlr_scene_shadow_create(c->scene, 0, 0, c->corner_radius, shadow_blur_sigma, shadow_color);
+		/* Lower the shadow below the border */
+		wlr_scene_node_lower_to_bottom(&c->shadow->node);
+	}
+#ifdef XWAYLAND
+	}
+#endif
+
 	/* Initialize client geometry with room for border */
 	client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 	c->geom.width += 2 * c->bw;
@@ -2139,6 +2239,8 @@ rendermon(struct wl_listener *listener, void *data)
 			goto skip;
 	}
 
+	output_configure_scene(&m->scene_output->scene->tree.node, NULL);
+
 	/*
 	 * HACK: The "correct" way to set the gamma is to commit it together with
 	 * the rest of the state in one go, but to do that we would need to rewrite
@@ -2233,6 +2335,21 @@ resize(Client *c, struct wlr_box geo, int interact)
 			c->geom.height - 2 * c->bw);
 	client_get_clip(c, &clip);
 	wlr_scene_subsurface_tree_set_clip(&c->scene_surface->node, &clip);
+
+	if (corner_radius > 0 && c->round_border) {
+		wlr_scene_node_set_position(&c->round_border->node, 0, 0);
+		wlr_scene_rect_set_size(c->round_border, c->geom.width, c->geom.height);
+		wlr_scene_rect_set_clipped_region(c->round_border, (struct clipped_region) {
+			.corner_radius = c->corner_radius,
+			.corners = CORNER_LOCATION_ALL,
+			.area = { c->bw, c->bw, c->geom.width - c->bw * 2, c->geom.height - c->bw * 2 }
+		});
+	}
+
+	if (shadow && c->shadow) {
+		/* TODO: shouldn't we call wlr_scene_shadow_set_blur_sigma? */
+		client_set_shadow_blur_sigma(c, (int)round(c->shadow->blur_sigma));
+	}
 }
 
 void
@@ -2333,6 +2450,13 @@ setfloating(Client *c, int floating)
 {
 	Client *p = client_get_parent(c);
 	c->isfloating = floating;
+
+	update_client_corner_radius(c);
+
+	update_client_shadow_color(c);
+
+	update_client_blur(c);
+
 	/* If in floating layout do not change the client's layer */
 	if (!c->mon || !client_surface(c)->mapped || !c->mon->lt[c->mon->sellt]->arrange)
 		return;
@@ -2362,6 +2486,13 @@ setfullscreen(Client *c, int fullscreen)
 		 * client positions are set by the user and cannot be recalculated */
 		resize(c, c->prev, 0);
 	}
+
+	update_client_corner_radius(c);
+
+	update_client_shadow_color(c);
+
+	update_client_blur(c);
+
 	arrange(c->mon);
 	printstatus();
 }
@@ -2483,11 +2614,15 @@ setup(void)
 	drag_icon = wlr_scene_tree_create(&scene->tree);
 	wlr_scene_node_place_below(&drag_icon->node, &layers[LyrBlock]->node);
 
+	if (blur) {
+		wlr_scene_set_blur_data(scene, blur_data);
+	}
+
 	/* Autocreates a renderer, either Pixman, GLES2 or Vulkan for us. The user
 	 * can also specify a renderer using the WLR_RENDERER env var.
 	 * The renderer is responsible for defining the various pixel formats it
 	 * supports for shared memory, this configures that for clients. */
-	if (!(drw = wlr_renderer_autocreate(backend)))
+	if (!(drw = fx_renderer_create(backend)))
 		die("couldn't create renderer");
 	LISTEN_STATIC(&drw->events.lost, gpureset);
 
@@ -2896,6 +3031,10 @@ updatemons(struct wl_listener *listener, void *data)
 
 		wlr_scene_node_set_position(&m->fullscreen_bg->node, m->m.x, m->m.y);
 		wlr_scene_rect_set_size(m->fullscreen_bg, m->m.width, m->m.height);
+		
+		if (blur) {
+			wlr_scene_optimized_blur_set_size(m->blur_layer, m->m.width, m->m.height);
+		}
 
 		if (m->lock_surface) {
 			struct wlr_scene_tree *scene_tree = m->lock_surface->surface->data;
@@ -2966,8 +3105,11 @@ urgent(struct wl_listener *listener, void *data)
 	c->isurgent = 1;
 	printstatus();
 
-	if (client_surface(c)->mapped)
+	if (client_surface(c)->mapped) {
 		client_set_border_color(c, urgentcolor);
+
+		update_client_focus_decorations(c, 1, 1);
+	}
 }
 
 void
